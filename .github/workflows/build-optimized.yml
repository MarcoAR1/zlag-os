name: Build Z-Gate OS (Smart Cache Multi-Arch)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  # ==============================================================================
  # Job 1: Base Environment (Común para todos)
  # ==============================================================================
  build-base-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      base_image: ${{ steps.repo.outputs.base_image }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set base image name
        id: repo
        run: |
          echo "base_image=ghcr.io/$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')/zgate-base:v1" >> $GITHUB_OUTPUT

      - name: Build Base Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.base
          push: true
          tags: ${{ steps.repo.outputs.base_image }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==============================================================================
  # Job 2: Buildroot Compiler (Dividido por Arquitectura)
  # ==============================================================================
  build-compiled-image:
    needs: build-base-image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        arch: [x86_64, arm64] # <--- AQUÍ ESTÁ LA MAGIA
    
    outputs:
      # Exportamos dinámicamente los tags para el siguiente job
      image-x86_64: ${{ steps.export.outputs.x86_64 }}
      image-arm64: ${{ steps.export.outputs.arm64 }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Calculate Config Hash
        id: config-hash
        run: |
          # El hash depende de los archivos de configuración
          HASH=$(cat configs/* scripts/* board/zgate/* | sha256sum | head -c 16)
          echo "hash=${HASH}" >> $GITHUB_OUTPUT

      - name: Set Docker Metadata
        id: meta
        run: |
          # Creamos un nombre ÚNICO por arquitectura
          IMG="ghcr.io/$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')/zgate-compiled-${{ matrix.arch }}"
          TAG="${{ steps.config-hash.outputs.hash }}"
          echo "full_tag=${IMG}:${TAG}" >> $GITHUB_OUTPUT

      - name: Check Cache
        id: check
        run: |
          if docker pull ${{ steps.meta.outputs.full_tag }} 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✅ Caché encontrado para ${{ matrix.arch }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "⚠️ Recompilando Kernel para ${{ matrix.arch }}..."
          fi

      - name: Login to GHCR
        if: steps.check.outputs.exists == 'false'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Kernel
        if: steps.check.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.compiled
          push: true
          tags: ${{ steps.meta.outputs.full_tag }}
          # Pasamos la arquitectura como argumento al Dockerfile
          build-args: |
            BASE_IMAGE=${{ needs.build-base-image.outputs.base_image }}
            ARCH=${{ matrix.arch }}

  # ==============================================================================
  # Job 3: Final Assembly (Ensamblaje Rápido)
  # ==============================================================================
  # ==============================================================================
  # Job 3: Final Assembly (Ensamblaje Rápido)
  # ==============================================================================
  assemble-final-iso:
    needs: build-compiled-image
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64, arm64]
        include:
          - arch: x86_64
            artifact_name: zgate-vultr-x86_64
          - arch: arm64
            artifact_name: zgate-oracle-arm64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Calculate Hash (Again)
        id: config-hash
        run: |
          HASH=$(cat configs/* scripts/* board/zgate/* | sha256sum | head -c 16)
          echo "hash=${HASH}" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Final Image
        run: |
          IMG="ghcr.io/$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')/zgate-compiled-${{ matrix.arch }}:${{ steps.config-hash.outputs.hash }}"
          
          echo "⚡ Usando imagen cacheada: $IMG"
          
          # 1. Montamos 'bin' para meter el agente nuevo
          # 2. Montamos 'output' del host a '/buildroot/output' del container
          # 3. NO PASAMOS COMANDO: Dejamos que el Entrypoint haga el trabajo sucio
          docker run --rm \
            -v $(pwd)/bin:/workspace/bin:ro \
            -v $(pwd)/output:/buildroot/output \
            $IMG

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          # Buildroot siempre deja los resultados finales aquí:
          path: output/images/
          retention-days: 7
    needs: build-compiled-image
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64, arm64]
        include:
          - arch: x86_64
            artifact_name: zgate-vultr-x86_64
            output_dir: output/vultr-x86_64
          - arch: arm64
            artifact_name: zgate-oracle-arm64
            output_dir: output/oracle-arm64

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Calculate Hash (Again)
        id: config-hash
        run: |
          HASH=$(cat configs/* scripts/* board/zgate/* | sha256sum | head -c 16)
          echo "hash=${HASH}" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Final Image
        run: |
          # Reconstruimos el nombre de la imagen basado en el hash actual y la arquitectura
          IMG="ghcr.io/$(echo ${{ github.repository_owner }} | tr '[:upper:]' '[:lower:]')/zgate-compiled-${{ matrix.arch }}:${{ steps.config-hash.outputs.hash }}"
          
          echo "⚡ Usando imagen cacheada: $IMG"
          
          docker run --rm \
            -v $(pwd)/bin:/workspace/bin:ro \
            -v $(pwd)/output:/buildroot/isos \
            $IMG \
            /bin/bash -c "./setup.sh update ${{ matrix.arch }}"

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: ${{ matrix.output_dir }}
          retention-days: 7
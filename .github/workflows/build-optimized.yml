name: Build Z-Gate OS (Smart Cache Multi-Arch)

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'buildroot/**'
      - 'bin/**'
      - 'configs/**'
      - 'scripts/**'
      - '.github/workflows/build-optimized.yml'
  workflow_dispatch:

env:
  REGISTRY: ghcr.io

jobs:
  # ==============================================================================
  # Job 1: Base Environment
  # ==============================================================================
  build-base-image:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      base_image: ${{ steps.repo.outputs.base_image }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      - name: Set base image name
        id: repo
        run: |
          # Convertir a minúsculas para cumplir con estándares de GHCR
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          echo "base_image=ghcr.io/${OWNER_LC}/zgate-base:v1" >> $GITHUB_OUTPUT

      - name: Build and Push Base
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.base
          push: true
          tags: ${{ steps.repo.outputs.base_image }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ==============================================================================
  # Job 2: Buildroot Compiler (Segregado por Arquitectura con Smart Cache)
  # ==============================================================================
  build-compiled-image:
    needs: build-base-image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        arch: [x86_64, arm64]
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Calculate Config Hash
        id: config-hash
        run: |
          # Hasheamos los archivos que definen la estructura del OS
          # Si cambias el binario, el hash NO cambia, reutilizando este Job.
          HASH=$(cat configs/* scripts/* board/zgate/* | sha256sum | head -c 16)
          echo "hash=${HASH}" >> $GITHUB_OUTPUT

      - name: Set Docker Metadata
        id: meta
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMG="ghcr.io/${OWNER_LC}/zgate-compiled-${{ matrix.arch }}"
          TAG="${{ steps.config-hash.outputs.hash }}"
          echo "full_tag=${IMG}:${TAG}" >> $GITHUB_OUTPUT

      - name: Check Cache
        id: check
        run: |
          if docker pull ${{ steps.meta.outputs.full_tag }} 2>/dev/null; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "✅ Caché de Kernel encontrado para ${{ matrix.arch }}"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "⚠️ Configuración nueva: Recompilando Kernel para ${{ matrix.arch }}..."
          fi

      - name: Login to GHCR
        if: steps.check.outputs.exists == 'false'
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and Push Compiled Kernel
        if: steps.check.outputs.exists == 'false'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: Dockerfile.compiled
          push: true
          tags: ${{ steps.meta.outputs.full_tag }}
          build-args: |
            BASE_IMAGE=${{ needs.build-base-image.outputs.base_image }}
            ARCH=${{ matrix.arch }}

  # ==============================================================================
  # Job 3: Final Assembly (Inyección de Binarios y Generación de ISO)
  # ==============================================================================
  assemble-final-iso:
    needs: build-compiled-image
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86_64, arm64]
        include:
          - arch: x86_64
            artifact_name: zgate-vultr-x86_64
          - arch: arm64
            artifact_name: zgate-oracle-arm64

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Calculate Hash (Para identificar imagen)
        id: config-hash
        run: |
          HASH=$(cat configs/* scripts/* board/zgate/* | sha256sum | head -c 16)
          echo "hash=${HASH}" >> $GITHUB_OUTPUT

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Final Image (${{ matrix.arch }})
        run: |
          OWNER_LC=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMG="ghcr.io/${OWNER_LC}/zgate-compiled-${{ matrix.arch }}:${{ steps.config-hash.outputs.hash }}"
          
          echo "⚡ Usando compilador pre-calentado: $IMG"
          
          # Mapeamos 'bin/' local que contiene:
          # - z-gate-agent-x86_64
          # - z-gate-agent-arm64
          # El entrypoint detectará su arquitectura y usará el correcto.
          docker run --rm \
            -v $(pwd)/bin:/workspace/bin:ro \
            -v $(pwd)/output:/buildroot/output \
            $IMG

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          # Los resultados finales aparecen aquí gracias al volumen mapeado
          path: output/images/
          retention-days: 7